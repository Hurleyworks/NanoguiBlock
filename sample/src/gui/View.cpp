// This source file was auto-generated by ClassMate++
// Created: 25 Oct 2015 1:51:10 pm
// Copyright (c) 2015, HurleyWorks

#include "View.h"


using namespace nanogui;
using namespace ci;
using std::cout;
using std::cerr;
using std::endl;

// ctor
View::View ()
   : nanogui::Screen()
{
   mTheme = new Theme (mNVGContext);
}

// dtor
View::~View ()
{
}

void View::create (WindowRef & ciWindow, const fs::path & assetFolder)
{
   try
   {
      initGraph (&fps, GRAPH_RENDER_FPS, "Frame Time");
      initGraph (&cpuGraph, GRAPH_RENDER_MS, "CPU Time");

      setSize (ciWindow->getSize());

      nanogui::Window * window = new nanogui::Window (this, "Button demo");
      window->setPosition (ivec2 (15, 15));
      window->setLayout (new GroupLayout());
      /* No need to store a pointer, the data structure will be automatically
         freed when the parent window is deleted */
      new Label (window, "Push buttons", "sans-bold");
      Button * b = new Button (window, "Plain button");
      b->setCallback ([] { cout << "pushed!" << endl; });
      b = new Button (window, "Styled", ENTYPO_ICON_ROCKET);
      b->setBackgroundColor (Colour (0, 0, 255, 25));
      b->setCallback ([] { cout << "pushed!" << endl; });
      new Label (window, "Toggle buttons", "sans-bold");
      b = new Button (window, "Toggle me");
      b->setFlags (Button::ToggleButton);
      b->setChangeCallback ([] (bool state)
      {
         cout << "Toggle button state: " << state << endl;
      });
      new Label (window, "Radio buttons", "sans-bold");
      b = new Button (window, "Radio button 1");
      b->setFlags (Button::RadioButton);
      b = new Button (window, "Radio button 2");
      b->setFlags (Button::RadioButton);
      new Label (window, "A tool palette", "sans-bold");
      Widget * tools = new Widget (window);
      tools->setLayout (new BoxLayout (Orientation::Horizontal,
                                       Alignment::Middle, 0, 6));
      b = new ToolButton (tools, ENTYPO_ICON_CLOUD);
      b = new ToolButton (tools, ENTYPO_ICON_FF);
      b = new ToolButton (tools, ENTYPO_ICON_COMPASS);
      b = new ToolButton (tools, ENTYPO_ICON_INSTALL);
      new Label (window, "Popup buttons", "sans-bold");
      PopupButton * popupBtn = new PopupButton (window, "Popup", ENTYPO_ICON_EXPORT);
      Popup * popup = popupBtn->popup();
      popup->setLayout (new GroupLayout());
      new Label (popup, "Arbitrary widgets can be placed here");
      new CheckBox (popup, "A check box");
      popupBtn = new PopupButton (popup, "Recursive popup", ENTYPO_ICON_FLASH);
      popup = popupBtn->popup();
      popup->setLayout (new GroupLayout());
      new CheckBox (popup, "Another check box");
      window = new nanogui::Window (this, "Basic widgets");
      window->setPosition (ivec2 (200, 15));
      window->setLayout (new GroupLayout());
      new Label (window, "Message dialog", "sans-bold");
      tools = new Widget (window);
      tools->setLayout (new BoxLayout (Orientation::Horizontal,
                                       Alignment::Middle, 0, 6));
      b = new Button (tools, "Info");
      b->setCallback ([&]
      {
         auto dlg = new MessageDialog (this, MessageDialog::Type::Information, "Title", "This is an information message");
         dlg->setCallback ([] (int result)
         {
            cout << "Dialog result: " << result << endl;
         });
      });
      b = new Button (tools, "Warn");
      b->setCallback ([&]
      {
         auto dlg = new MessageDialog (this, MessageDialog::Type::Warning, "Title", "This is a warning message");
         dlg->setCallback ([] (int result)
         {
            cout << "Dialog result: " << result << endl;
         });
      });
      b = new Button (tools, "Ask");
      b->setCallback ([&]
      {
         auto dlg = new MessageDialog (this, MessageDialog::Type::Warning, "Title", "This is a question message", "Yes", "No", true);
         dlg->setCallback ([] (int result)
         {
            cout << "Dialog result: " << result << endl;
         });
      });

	  std::string iconPath = assetFolder.string();
	  iconPath += "/icons";
     
      std::vector<std::pair<int, std::string>> icons = NanoUtil::loadImageDirectory (getContext(), iconPath);
      new Label (window, "Image panel & scroll panel", "sans-bold");
      PopupButton * imagePanelBtn = new PopupButton (window, "Image Panel");
      imagePanelBtn->setIcon (ENTYPO_ICON_FOLDER);
      popup = imagePanelBtn->popup();
      VScrollPanel * vscroll = new VScrollPanel (popup);
      ImagePanel * imgPanel = new ImagePanel (vscroll);
      imgPanel->setImages (icons);
      popup->setFixedSize (ivec2 (245, 150));
      new Label (window, "Selected image", "sans-bold");
      auto img = new ImageView (window);
      img->setFixedSize (ivec2 (40, 40));
      img->setImage (icons[0].first);
      imgPanel->setCallback ([ &, img, imgPanel, imagePanelBtn] (int i)
      {
         img->setImage (imgPanel->images()[i].first);
         cout << "Selected item " << i << endl;
      });
      new Label (window, "Combo box", "sans-bold");
      new ComboBox (window, { "Combo box item 1", "Combo box item 2", "Combo box item 3" });
      new Label (window, "Check box", "sans-bold");
      CheckBox * cb = new CheckBox (window, "Flag 1",
                                    [] (bool state)
      {
         cout << "Check box 1 state: " << state << endl;
      }
                                   );
      cb->setChecked (true);
      cb = new CheckBox (window, "Flag 2",
                         [] (bool state)
      {
         cout << "Check box 2 state: " << state << endl;
      }
                        );
      new Label (window, "Progress bar", "sans-bold");
      mProgress = new ProgressBar (window);
      new Label (window, "Slider and text box", "sans-bold");
      Widget * panel = new Widget (window);
      panel->setLayout (new BoxLayout (Orientation::Horizontal,
                                       Alignment::Middle, 0, 20));
      Slider * slider = new Slider (panel);
      slider->setValue (0.5f);
      slider->setFixedWidth (80);
      TxtBox * textBox = new TxtBox (panel);
      textBox->setFixedSize (ivec2 (60, 25));
      textBox->setValue ("50");
      textBox->setUnits ("%");
      slider->setCallback ([textBox] (float value)
      {
         textBox->setValue (std::to_string ((int) (value * 100)));
      });
      slider->setFinalCallback ([&] (float value)
      {
         cout << "Final slider value: " << (int) (value * 100) << endl;
      });
      textBox->setFixedSize (ivec2 (60, 25));
      textBox->setFontSize (20);
      textBox->setAlignment (TxtBox::Alignment::Right);


	  window = new nanogui::Window(this, "Misc. widgets");
	  window->setPosition(ivec2(425, 15));
	  window->setLayout(new GroupLayout());
	  new Label(window, "Color wheel", "sans-bold");
	  new ColorWheel(window);
	  new Label(window, "Function graph", "sans-bold");
	  Graph *graph = new Graph(window, "Some function");
	  graph->setHeader("E = 2.35e-3");
	  graph->setFooter("Iteration 89");
	  std::vector<float> &func = graph->values();
	  func.resize(100);
	  for (int i = 0; i < 100; ++i)
		  func[i] = 0.5f * (0.5f * std::sin(i / 10.f) +
			  0.5f * std::cos(i / 23.f) + 1);

	  window = new nanogui::Window(this, "Grid of small widgets");
	  window->setPosition(ivec2(425, 288));
	  GridLayout *layout =
		  new GridLayout(Orientation::Horizontal, 2,
			  Alignment::Middle, 15, 5);
	  layout->setColAlignment(
	  { Alignment::Maximum, Alignment::Fill });
	  layout->setSpacing(0, 10);
	  window->setLayout(layout);

	  {
		  new Label(window, "Floating point :", "sans-bold");
		  textBox = new TxtBox(window);
		  textBox->setEditable(true);
		  textBox->setFixedSize(ivec2(100, 20));
		  textBox->setValue("50");
		  textBox->setUnits("GiB");
		  textBox->setDefaultValue("0.0");
		  textBox->setFontSize(16);
		  textBox->setFormat("[-]?[0-9]*\\.?[0-9]+");
	  }

	  {
		  new Label(window, "Positive integer :", "sans-bold");
		  textBox = new TxtBox(window);
		  textBox->setEditable(true);
		  textBox->setFixedSize(ivec2(100, 20));
		  textBox->setValue("50");
		  textBox->setUnits("Mhz");
		  textBox->setDefaultValue("0.0");
		  textBox->setFontSize(16);
		  textBox->setFormat("[1-9][0-9]*");
	  }

	  {
		  new Label(window, "Checkbox :", "sans-bold");

		  cb = new CheckBox(window, "Check me");
		  cb->setFontSize(16);
		  cb->setChecked(true);
	  }

	  new Label(window, "Combo box :", "sans-bold");
	  ComboBox *cobo =
		  new ComboBox(window, { "Item 1", "Item 2", "Item 3" });
	  cobo->setFontSize(16);
	  cobo->setFixedSize(ivec2(100, 20));

	  new Label(window, "Color button :", "sans-bold");
	  popupBtn = new PopupButton(window, "", 0);
	  popupBtn->setBackgroundColor(Colour(255, 120, 0, 255));
	  popupBtn->setFontSize(16);
	  popupBtn->setFixedSize(ivec2(100, 20));
	  popup = popupBtn->popup();
	  popup->setLayout(new GroupLayout());

	  ColorWheel *colorwheel = new ColorWheel(popup);
	  colorwheel->setColor(popupBtn->backgroundColor());

	  Button *colorBtn = new Button(popup, "Pick");
	  colorBtn->setFixedSize(ivec2(100, 25));
	  Colour c = colorwheel->color();
	  colorBtn->setBackgroundColor(c);

	  colorwheel->setCallback([colorBtn](const Colour &value) {
		  colorBtn->setBackgroundColor(value);
	  });

	  colorBtn->setChangeCallback([colorBtn, popupBtn](bool pushed) {
		  if (pushed) {
			  popupBtn->setBackgroundColor(colorBtn->backgroundColor());
			  popupBtn->setPushed(false);
		  }
	  });

      performLayout (mNVGContext);
   }
   catch (const std::exception & e)
   {
      std::cout << e.what() << std::endl;
   }
}

void View::draw (double time)
{
   mProgress->setValue (std::fmod ((float)time / 10, 1.0f));
   drawWidgets();
   float x = 5;
   float y = mSize[1] - 40;
   renderGraph (mNVGContext, x, y, &fps, nvgRGBA (128, 0, 0, 255));
   renderGraph (mNVGContext, x + 200 + 5, y, &cpuGraph, nvgRGBA (0, 128, 0, 255));
}

bool View::mouseMove (MouseEvent e)
{
   return cursorPosCallbackEvent (e.getPos().x, e.getPos().y);
}

bool View::mouseDown (MouseEvent e)
{
   if (!e.isLeft()) return false;
   return mouseButtonCallbackEvent (MOUSE_BUTTON_LEFT, PRESS, 0);
}

bool View::mouseDrag (MouseEvent e)
{
   if (!e.isLeftDown()) return false;
   return cursorPosCallbackEvent (e.getPos().x, e.getPos().y);
}

bool View::mouseUp (MouseEvent e)
{
   if (!e.isLeft()) return false;
   return mouseButtonCallbackEvent (MOUSE_BUTTON_LEFT, RELEASE, 0);
}

bool View::keyDown(KeyEvent e)
{
	if(e.getChar() > 32)
		charCallbackEvent(e.getChar());
	return keyCallbackEvent( e.getCode(), 0, PRESS, 0);
}

bool View::keyUp(KeyEvent e)
{
	return keyCallbackEvent(e.getCode(), 0, RELEASE, 0);
}

void View::updatePerfGraph (float dt, float cpuTime)
{
   updateGraph (&fps, dt);
   updateGraph (&cpuGraph, cpuTime);
}


